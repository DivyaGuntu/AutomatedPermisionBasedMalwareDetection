package com.tsu.securityanalysis;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

import android.os.Environment;
import android.util.Log;

import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.bayes.NaiveBayes;
import weka.classifiers.evaluation.output.prediction.PlainText;
import weka.classifiers.trees.J48;
import weka.classifiers.trees.RandomForest;
import weka.core.Instances;

public class Classification {
	
 String featurecsvpath = Environment.getExternalStorageDirectory() +"/SecurityAnalysis/";
 String[] Feature_List;
 
 public void getFeatureCountAndList() throws IOException
 {   
	 String filePath = featurecsvpath+"TestingSet.csv";
     int i = 0;
	 try {
		 CSVReader reader = new CSVReader(new FileReader(filePath));
	     Feature_List = reader.readNext();
	     reader.close();	
	} 
	 	 catch (FileNotFoundException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
 }

 public void WriteFeatureCSV(ArrayList<String> feature_vector)
			throws IOException {
	    getFeatureCountAndList();
	    int feature_count = Feature_List.length;
        String filePath = featurecsvpath+"TestingSet.csv";
		String[] CSV_Vector = new String[154];
        try{
		CSVWriter csvOutput = new CSVWriter(new FileWriter(filePath, true));
        CSV_Vector[0] = feature_vector.get(0);
        System.out.println(CSV_Vector[0]);
        CSV_Vector[1] = feature_vector.get(1);       
       	for (int i = 2; i < feature_count-1; i++) {
			CSV_Vector[i] = "no";
			for (int j = 2; j < feature_vector.size()-1; j++) {
				if (Feature_List[i].equals(feature_vector.get(j))) {
					CSV_Vector[i] = "yes";
					break;
				}
			}
        }
       	CSV_Vector[feature_count-1] = "?";
		csvOutput.writeNext(CSV_Vector, true);
		csvOutput.close();
        }
        catch(Exception e){
        	Log.d("Exception",""+e.getMessage());
        }
 }
 public void createFeaturearff() {
		System.out.println("In create function");
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(featurecsvpath+"TestingSet.csv"));
		} catch (FileNotFoundException e) {
			System.out.println("The features.csv file does not exist");
			e.printStackTrace();
			return;
		}
       try
       {
		FileWriter writer = new FileWriter(featurecsvpath + "TestingSet.arff");
		BufferedWriter arffwriter = new BufferedWriter(writer);
		arffwriter.write("@relation APPLICATION_MANIFEST_ATTRIBUTES");
		arffwriter.newLine();
		arffwriter.newLine();
		String header = reader.readLine();
		String[] attribute_list = header.split(",");
		for (int i = 2; i < attribute_list.length; i++) {
			arffwriter.write("@attribute " + attribute_list[i] + " {yes,no}");
			arffwriter.newLine();
		}
		arffwriter.newLine();
		arffwriter.newLine();
		arffwriter.write("@data");
		String data;
		while ((data = reader.readLine()) != null) {
			String[] arffdata = data.split(",");
			arffwriter.newLine();
			for(int j = 2; j<arffdata.length-1;j++){
			arffwriter.write(arffdata[j]+",");
			}
			arffwriter.write('?');
		}
		arffwriter.close();
		reader.close();
		classifyNaiveBayes();
		classifyRandomForest();
       }
       catch(Exception e){
    	   Log.d("Exception",""+e.getMessage());
       }
	}

	public void classifyNaiveBayes() throws Exception {
		String trainingset = featurecsvpath+"TrainingSet.arff";
        String testingset = featurecsvpath+"TestingSet.arff";
		BufferedReader buffer1 = null;
		BufferedReader buffer2 = null;
		buffer1 = new BufferedReader(new FileReader(trainingset));
		buffer2 = new BufferedReader(new FileReader(testingset));
		Instances train = new Instances(buffer1);
	    Instances test = new Instances(buffer2);
	    train.setClassIndex(train.numAttributes() - 1);
	    test.setClassIndex(train.numAttributes() - 1);
	    StringBuffer prediction = new StringBuffer();
	    PlainText plainText = new PlainText();
        plainText.setBuffer(prediction);
				 // train classifier
	    Classifier cls = new  NaiveBayes();
        cls.buildClassifier(train);
	    // evaluate classifier and print some statistics
	    Evaluation eval = new Evaluation(train);
		eval.evaluateModel(cls, test);
		for (int i = 0; i < test.numInstances(); i++) {
			   double pred = cls.classifyInstance(test.instance(i));
			   System.out.print("ID: " + test.instance(i).value(0));
			   System.out.print(", actual: " + test.classAttribute().value((int) test.instance(i).classValue()));
			   System.out.println(", predicted: " + test.classAttribute().value((int) pred));
			 }

	    System.out.println(eval.toSummaryString("\nResults\n======\n", false));
	    System.out.println(prediction.toString());
	}
	public void classifyRandomForest() throws Exception {
		String trainingset = featurecsvpath+"TrainingSet.arff";
        String testingset = featurecsvpath+"TestingSet.arff";
		BufferedReader buffer1 = null;
		BufferedReader buffer2 = null;
		buffer1 = new BufferedReader(new FileReader(trainingset));
		buffer2 = new BufferedReader(new FileReader(testingset));
		Instances train = new Instances(buffer1);
	    Instances test = new Instances(buffer2);
	    train.setClassIndex(train.numAttributes() - 1);
	    test.setClassIndex(train.numAttributes() - 1);
				 // train classifier
	    Classifier cls = new  RandomForest();
        cls.buildClassifier(train);
	    // evaluate classifier and print some statistics
	    Evaluation eval = new Evaluation(train);
		eval.evaluateModel(cls, test);
		for (int i = 0; i < test.numInstances(); i++) {
			   double pred = cls.classifyInstance(test.instance(i));
			   System.out.print("ID: " + test.instance(i).value(0));
			   System.out.print(", actual: " + test.classAttribute().value((int) test.instance(i).classValue()));
			   System.out.println(", predicted: " + test.classAttribute().value((int) pred));
			 }
	}
	}


